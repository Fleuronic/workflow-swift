/*
 * Copyright 2020 Square Inc.
 * Copyright 2024 Fleuronic LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// Conforming types can be converted into `AnyWorkflow` values, allowing them to participate
/// in a workflow hierarchy.
public protocol AnyWorkflowConvertible<Rendering, Output> {
	/// The rendering type of this type's `AnyWorkflow` representation
	associatedtype Rendering

	/// The output type of this type's `AnyWorkflow` representation
	associatedtype Output

	/// Returns an `AnyWorkflow` representing this value.
	func asAnyWorkflow() -> AnyWorkflow<Rendering, Output>
}

// MARK: -
public extension AnyWorkflowConvertible {
	/// Creates or updates a child workflow of the given type, performs a render pass, and returns the result.
	///
	/// Note that it is a programmer error to render two instances of a given workflow type with the same `key`
	/// during the same render pass.
	///
	/// - Parameter context: The context with which the workflow will be rendered.
	/// - Parameter key: A string that uniquely identifies this workflow.
	///
	/// - Returns: The `Rendering` generated by the workflow.
	func rendered<Parent>(in context: RenderContext<Parent>, key: String = "") -> Rendering where Output: WorkflowAction, Output.WorkflowType == Parent {
		asAnyWorkflow().render(
			context: context, 
			key: key, 
			outputMap: { $0 }
		)
	}

	func rendered<Parent, Action: WorkflowAction>(in context: RenderContext<Parent>, key: String = "", outputMap: @escaping (Output) -> Action) -> Rendering where Action.WorkflowType == Parent {
		asAnyWorkflow().render(
			context: context, 
			key: key, 
			outputMap: outputMap
		)
	}

	func rendered<Parent>(in context: RenderContext<Parent>, key: String = "") -> Rendering where Output == AnyWorkflowAction<Parent> {
		asAnyWorkflow().render(
			context: context, 
			key: key, 
			outputMap: { $0 }
		)
	}
	
	/// Process an `Output`
	///
	/// - Parameter apply: On `Output`, mutate `State` as necessary and return new `Output` (or `nil`).
	func onOutput<Parent>(_ apply: @escaping ((inout Parent.State, Output) -> Parent.Output?)) -> AnyWorkflow<Rendering, AnyWorkflowAction<Parent>> {
		asAnyWorkflow().mapOutput { output in
			.init { state in apply(&state, output) }
		}
	}
	
	/// Wraps this workflow in a workflow that ignores all outputs.
	///
	/// - Returns: An `AnyWorkflow` with the same rendering and no output.
	func ignoringOutput() -> AnyWorkflow<Rendering, Never> {
		OutputBlockingWorkflow(child: self).asAnyWorkflow()
	}
}

public extension AnyWorkflowConvertible where Output == Never {
	/// Creates or updates a child workflow of the given type, performs a render pass, and returns the result.
	///
	/// Note that it is a programmer error to render two instances of a given workflow type with the same `key`
	/// during the same render pass.
	///
	/// - Parameter context: The context with which the workflow will be rendered.
	/// - Parameter key: A string that uniquely identifies this workflow.
	///
	/// - Returns: The `Rendering` generated by the workflow.
	func rendered<T>(in context: RenderContext<T>, key: String = "") -> Rendering {
		// Convenience for workflow that have no output allowing them to be rendered with any context
		asAnyWorkflow().render(
			context: context,
			key: key,
			outputMap: { _ -> AnyWorkflowAction<T> in }
		)
	}
}

public extension AnyWorkflowConvertible where Rendering == Void {
	func running<Parent, Action: WorkflowAction>(in context: RenderContext<Parent>, key: String = "", outputMap: @escaping (Output) -> Action) where Action.WorkflowType == Parent {
		rendered(in: context, key: key, outputMap: outputMap)
	}
}

public extension AnyWorkflowConvertible where Rendering == Void, Output: WorkflowAction {
	func running<Parent>(in context: RenderContext<Parent>, key: String = "") where Output.WorkflowType == Parent {
		rendered(in: context, key: key)
	}
}

// MARK: -
struct OutputBlockingWorkflow<Child: AnyWorkflowConvertible>: Workflow {
	typealias Output = Never
	typealias Rendering = Child.Rendering
	typealias State = Void

	var child: Child

	func render(
		state: Void, 
		context: RenderContext<OutputBlockingWorkflow<Child>>
	) -> Child.Rendering {
		child
			.mapOutput { _ in .noAction }
			.rendered(in: context)
	}
}
